/*
 * @(#)Filename.java	1.00 2002/07/15
 *
 * Copyright 1998-2002 by Viper Software Services
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Viper Software Services. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Viper Software Services.
 *
 * @Author Tom Nevin (TomNevin@pacbell.net)
 */

package com.viper.tools;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Canvas;
import java.awt.Choice;
import java.awt.Color;
import java.awt.Container;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.Panel;
import java.awt.Rectangle;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Vector;

import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JSeparator;
import javax.swing.KeyStroke;
import javax.swing.UIManager;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import com.viper.projections.Grid;
import com.viper.projections.MapPoint;
import com.viper.projections.MapProjection;

public class WorldParser {

	public static Vector segments = new Vector();

	public Grid worldXY = new Grid(-180.0, 180.0, -180.0, 180.0);
	public Grid world = new Grid(-180.0, 180.0, -180.0, 180.0);

	private MapProjection projection = MapProjection.getInstance("Passthru");
	private Document document = null;

	public WorldParser() {
	}

	public void Convert(String xmlFilename, boolean validate) {

		try {
			File file = new File(xmlFilename);
			if (file != null) {
				this.document = createDocument(file, validate);
				if (document != null) {
					processDocument(document);
				}
			}

		} catch (Exception e) {
			System.err.println("ERROR: " + e);
			System.err.println("     : xmlFilename=" + xmlFilename);
		}
	}

	public Document getDocument() {
		return this.document;
	}

	public boolean verify() {
		return true;
	}

	private Document createDocument(File file, boolean validate) {

		try {

			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

			factory.setNamespaceAware(true);

			factory.setValidating(validate);

			DocumentBuilder builder = factory.newDocumentBuilder();

			return builder.parse(file);

		} catch (ParserConfigurationException pce) {
			System.err.println("ERROR: " + pce);
		} catch (SAXParseException spe) {
			System.err.println("Error: " + spe + ":Line# = " + spe.getLineNumber() + " Col# = " + spe.getColumnNumber());
		} catch (SAXException se) {
			System.err.println("ERROR: " + se);
		} catch (IOException ioe) {
			System.err.println("ERROR: " + ioe);
		} catch (Exception e) {
			System.err.println("ERROR: " + e);
		}

		return null;
	}

	private double toDouble(String str) {
		if (str == null || str.length() == 0) {
			return 0.0;
		}

		try {
			return Double.parseDouble(str);
		} catch (Exception e) {
			System.err.println("toDouble: " + e + ": " + str);
		}
		return 0.0;
	}

	private int toInt(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}

		try {
			return Integer.parseInt(str);
		} catch (Exception e) {
			System.err.println("toInt: " + e + ": " + str);
		}
		return 0;
	}

	private void processDocument(Document document) {
		NodeList nodes = document.getChildNodes();
		if (nodes == null)
			return;

		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);

			if (node == null || node.getNodeType() != Node.ELEMENT_NODE)
				continue;

			Element element = (Element) node;
			String tagname = element.getTagName();
			if ("WorldData".equalsIgnoreCase(tagname)) {
				processWorldData(element);

			}
		}
	}

	// --------------------------------------------------------------------
	private void processWorldData(Element root) {
		NodeList nodes = root.getChildNodes();
		if (nodes == null)
			return;

		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);

			if (node.getNodeType() != Node.ELEMENT_NODE)
				continue;

			Element element = (Element) node;
			String tagname = element.getTagName();

			if ("Heading".equalsIgnoreCase(tagname)) {
				processHeading(element);

			} else if ("Segment".equalsIgnoreCase(tagname)) {
				processSegment(element);

			}
		}
	}

	// --------------------------------------------------------------------
	private String getValue(Element root) {
		if (root.getFirstChild() == null) {
			return "";
		}
		if (root.getFirstChild().getNodeValue() == null) {
			return "";
		}
		return root.getFirstChild().getNodeValue().trim();
	}

	// --------------------------------------------------------------------
	private String getCDATAValue(Element root) {
		String str = getValue(root);
		if (str.length() > 0) {
			return str;
		}

		NodeList nodes = root.getChildNodes();
		if (nodes == null)
			return "";

		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);
			if (node == null)
				continue;

			if (node.getNodeType() != Node.CDATA_SECTION_NODE)
				continue;

			return node.getNodeValue().trim();
		}
		return "";
	}

	// --------------------------------------------------------------------
	private void processHeading(Element root) {
		String txt = root.getFirstChild().getNodeValue();
	}

	// --------------------------------------------------------------------
	private void processSegment(Element root) {

		Segment segment = new Segment();
		segments.add(segment);

		segment.kind = (String) root.getAttribute("kind");

		NodeList nodes = root.getChildNodes();
		if (nodes == null)
			return;

		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);

			if (node.getNodeType() != Node.ELEMENT_NODE)
				continue;

			Element element = (Element) node;
			String tagname = element.getTagName();

			if ("Grid".equalsIgnoreCase(tagname)) {
				segment.grid = processGrid(element);

			} else if ("Pt".equalsIgnoreCase(tagname)) {
				segment.pts.add(processPt(element));

			}
		}
	}

	// --------------------------------------------------------------------
	private Grid processGrid(Element root) {

		Grid grid = new Grid();
		grid.south = toDouble((String) root.getAttribute("min_lat"));
		grid.north = toDouble((String) root.getAttribute("max_lat"));
		grid.west = toDouble((String) root.getAttribute("min_lon"));
		grid.east = toDouble((String) root.getAttribute("max_lon"));

		return grid;
	}

	// --------------------------------------------------------------------
	private MapPoint processPt(Element root) {

		MapPoint mp = new MapPoint();

		mp.lat = toDouble((String) root.getAttribute("lat"));
		mp.lon = toDouble((String) root.getAttribute("lon"));

		return mp;
	}

	// --------------------------------------------------------------------
	public void plotVector(Graphics g, Grid world, Rectangle view, Vector pts) {

		if (pts == null || pts.size() == 0) {
			return;
		}

		int height = (int) view.getHeight();
		int width = (int) view.getWidth();

		double sx = width / (world.east - world.west);
		double sy = height / (world.north - world.south);

		MapPoint pp1 = new MapPoint();
		MapPoint pp2 = new MapPoint();

		boolean foundFirst = false;

		for (int i = 0; i < pts.size(); i++) {
			MapPoint pt = (MapPoint) pts.elementAt(i);
			if (projection.inView(pt) == false)
				continue;

			if (foundFirst == false) {
				projection.toProjection(pt, pp1);
				foundFirst = true;
				continue;
			}

			projection.toProjection(pt, pp2);

			int x1 = (int) ((pp1.lon - world.west) * sx);
			int y1 = (int) ((pp1.lat - world.south) * sy);
			int x2 = (int) ((pp2.lon - world.west) * sx);
			int y2 = (int) ((pp2.lat - world.south) * sy);

			g.drawLine(x1, height - y1, x2, height - y2);

			pp1.lat = pp2.lat;
			pp1.lon = pp2.lon;
		}
	}

	// --------------------------------------------------------------------
	public void plotSegment(Graphics g, Grid world, Rectangle view, Segment segment) {

		g.setColor(Color.green);

		plotVector(g, world, view, segment.pts);
	}

	// --------------------------------------------------------------------
	public void plotSegments(Graphics g, Grid world, Rectangle view, Vector segments) {

		for (int i = 0; i < segments.size(); i++) {
			Segment s = (Segment) segments.elementAt(i);
			if (s == null)
				continue;

			plotSegment(g, world, view, s);
		}
	}

	// --------------------------------------------------------------------
	public void maxWorld(Grid world, Vector segments) {

		for (int i = 0; i < segments.size(); i++) {
			Segment s = (Segment) segments.elementAt(i);
			if (s == null)
				continue;

			for (int j = 0; j < s.pts.size(); j++) {
				MapPoint pt = (MapPoint) s.pts.elementAt(j);
				world.grow(pt);
			}
		}
	}

	public Grid getWorld() {
		return this.world;
	}

	public Grid getWorldXY() {
		return this.worldXY;
	}

	public MapProjection getProjection() {
		return this.projection;
	}

	class Segment {
		String kind = "land";

		Grid grid = new Grid();

		Vector pts = new Vector();
	}

	public void createWorldFrame(int width, int height) {

		JFrame frame = new JFrame("World Viewer");
		frame.setSize(width + 200, height);
	
		// Force SampleTree to come up in the Cross Platform L&F
		try {
			UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
			// If you want the System L&F instead, comment out the above line
			// and
			// uncomment the following:
			// UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception exc) {
			System.err.println("Error loading L&F: " + exc);
		}

		JMenuBar menuBar = createMenuPane();
		frame.setJMenuBar(menuBar);
		
		JPanel toolPane = createToolPane();
		ControlPanel controlPane = new ControlPanel();
		MapPanel mapPane = new MapPanel(this);
		mapPane.setSize(width, height);
		
		Container mainPane = frame.getContentPane();
		mainPane.setLayout(new BorderLayout());
		mainPane.add(toolPane, BorderLayout.NORTH);
		mainPane.add(mapPane, BorderLayout.CENTER);
		mainPane.add(controlPane, BorderLayout.WEST);

		frame.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});

		frame.pack();
		frame.show();
	}

	public JPanel createToolPane() {
		return new JPanel();
	}

	public JMenuBar createMenuPane() {
		// Menus
		JMenuBar menuBar = new JMenuBar();
		menuBar.getAccessibleContext().setAccessibleName("MenuBar.accessible_description");

		JMenu fileMenu = new JMenu("File");
		// fileMenu.setMnemonic(getMnemonic("FileMenu.file_mnemonic"));
		// fileMenu.getAccessibleContext().setAccessibleDescription(getString("FileMenu.accessible_description"));
		fileMenu.add(createMenuItem("Import...", null, null, null));
		fileMenu.add(createMenuItem("Export...", null, null, null));
		fileMenu.add(new JSeparator());
		fileMenu.add(createMenuItem("Exit", null, new ExitListener(), null));
		menuBar.add(fileMenu);

		JMenu editMenu = new JMenu("Edit");
		menuBar.add(editMenu);

		editMenu.add(createMenuItem("Cut", KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_DOWN_MASK), null, null));
		editMenu.add(createMenuItem("Copy", KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK), null, null));
		editMenu.add(createMenuItem("Paste", KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK), null, null));
		editMenu.add(createMenuItem("Paste Special...", null, null, null));
		editMenu.add(createMenuItem("Select All", KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK), null, null));
		editMenu.add(new JSeparator());
		editMenu.add(createMenuItem("Find..", KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_DOWN_MASK), null, null));

		JMenu viewMenu = new JMenu("View");
		menuBar.add(viewMenu);

		return menuBar;

	}

	private JMenuItem createMenuItem(String label, KeyStroke key, ActionListener listener, String tooltip) {
		JMenuItem menuItem = new JMenuItem(label);
		if (key != null) {
			menuItem.setAccelerator(key);
		}
		if (tooltip != null) {
			menuItem.setToolTipText(tooltip);
		}
		if (listener != null) {
			menuItem.addActionListener(listener);
		}
		return menuItem;
	}

	public class ControlPanel extends Panel implements ActionListener {

		Label latWorld = new Label("XX-XX-XX XX-XX-XX");
		Label lonWorld = new Label("XX-XX-XX XX-XX-XX");
		Label latView = new Label("XX-XX-XX XX-XX-XX");
		Label lonView = new Label("XX-XX-XX XX-XX-XX");

		TextField radiusTF = new TextField();
		TextField eccTF = new TextField();
		TextField latOriginTF = new TextField();
		TextField lonOriginTF = new TextField();
		TextField sp1TF = new TextField();
		TextField sp2TF = new TextField();

		Button plotBtn = new Button("Plot");

		public ControlPanel() {
			super();

			setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

			add(new ProjectionChoice());

			add(new Label("World"));
			add(latWorld);
			add(lonWorld);

			add(new Label("View"));
			add(latView);
			add(lonView);

			Panel grid = new Panel(new GridLayout(4, 2));
			grid.add(new Label("Radius:"));
			grid.add(radiusTF);
			grid.add(new Label("Eccentricity:"));
			grid.add(eccTF);
			grid.add(new Label("SP1:"));
			grid.add(sp1TF);
			grid.add(new Label("SP2:"));
			grid.add(sp2TF);
			add(grid);

			add(new Label("Origin:"));
			add(latOriginTF);
			add(lonOriginTF);

			add(plotBtn);

			plotBtn.addActionListener(this);
		}

		public int fix(double d) {
			return (int) (d - (d % 1.0));
		}

		private String getLatText(double lat) {
			String dir = (lat < 0.0) ? "S" : "N";

			lat = (lat < 0.0) ? -lat : lat;

			int deg = fix(lat);
			int min = fix((lat % 1.0) * 60.0);
			int sec = fix((lat % (1.0 / 60.0)) * 3600.0);

			return deg + "." + min + "." + sec + dir;
		}

		private String getLonText(double lon) {
			String dir = (lon < 0.0) ? "W" : "E";

			lon = (lon < 0.0) ? -lon : lon;

			int deg = fix(lon);
			int min = fix((lon % 1.0) * 60.0);
			int sec = fix((lon % (1.0 / 60.0)) * 3600.0);

			return deg + "." + min + "." + sec + dir;
		}

		public void refresh() {

			MapProjection MP = getProjection();

			Grid world = getWorld();
			Grid worldXY = getWorldXY();

			latWorld.setText(getLatText(world.getNorth()) + " " + getLatText(world.getSouth()));
			lonWorld.setText(getLonText(world.getEast()) + " " + getLonText(world.getWest()));

			latView.setText(getLatText(worldXY.getNorth()) + " " + getLatText(worldXY.getSouth()));
			lonView.setText(getLonText(worldXY.getEast()) + " " + getLonText(worldXY.getWest()));

			sp1TF.setText("" + MP.getParallel1());
			sp2TF.setText("" + MP.getParallel2());

			latOriginTF.setText("" + MP.getOriginLat());
			lonOriginTF.setText("" + MP.getOriginLon());

			radiusTF.setText("" + MP.getRadius());
			eccTF.setText("" + MP.getEccentricity());

			validate();
		}

		public void actionPerformed(ActionEvent event) {

			MapProjection MP = getProjection();

			MP.setRadius(toDouble(radiusTF.getText()));
			MP.setEccentricity(toDouble(eccTF.getText()));
			MP.setParallel1(toDouble(sp1TF.getText()));
			MP.setParallel2(toDouble(sp2TF.getText()));

			MP.setOriginLat(toDouble(latOriginTF.getText()));
			MP.setOriginLon(toDouble(lonOriginTF.getText()));

		}
	}

	public class ProjectionChoice extends Choice implements ItemListener {
		public ProjectionChoice() {
			super();
			add("Albers");
			add("Azimuthal");
			add("Bonne");
			add("Cassini");
			add("CylindricalEqualArea");
			add("EquidistantConic");
			add("EquidistantCylindrical");
			add("Gnomonic");
			add("LambertConformalConic");
			add("LambertEqualArea");
			add("Mercator");
			add("Miller");
			add("Orthographic");
			add("Passthru");
			add("Polyconic");
			add("SpaceObliqueMercator");
			add("Stereographic");
			add("TransverseMercator");
			add("UTM");
			add("VerticalPerspective");

			addItemListener(this);
		}

		/**
		 * Invoked when an item has been selected or deselected by the user. The
		 * code written for this method performs the operations that need to
		 * occur when an item is selected (or deselected).
		 */
		public void itemStateChanged(ItemEvent event) {

			if (event.getStateChange() != event.SELECTED) {
				return;
			}

			Object item = event.getItem();
			if (!(item instanceof String)) {
				return;
			}

			projection = MapProjection.getInstance((String) item);
		}
	}

	public class MapPanel extends Canvas {

		WorldParser parser = null;

		public MapPanel(WorldParser parser) {
			super();
			this.parser = parser;
		}

		public void paintGrid(Graphics g, Grid worldXY, Grid world, Rectangle view) {

			g.setColor(Color.black);

			double dx = (world.east - world.west) / 10;
			double dy = (world.north - world.south) / 10;

			Vector pts = parser.projection.createVector(20);
			MapPoint pt1 = new MapPoint();
			MapPoint pt2 = new MapPoint();

			MapProjection MP = parser.getProjection();

			for (double x = world.west; x <= world.east; x = x + dx) {
				for (double y = world.south; y < (world.north - dy / 2.0); y = y + dy) {
					pt1.lat = y;
					pt1.lon = x;
					pt2.lat = y + dy;
					pt2.lon = x;

					MP.computeLine(pts, pt1, pt2);
					parser.plotVector(g, worldXY, view, pts);
				}
			}

			for (double y = world.south; y <= world.north; y = y + dy) {
				for (double x = world.west; x < (world.east - dx / 2.0); x = x + dx) {

					pt1.lat = y;
					pt1.lon = x;
					pt2.lat = y;
					pt2.lon = x + dx;

					MP.computeLine(pts, pt1, pt2);
					parser.plotVector(g, worldXY, view, pts);
				}
			}
		}

		public void paint(Graphics g) {
			setBackground(Color.blue);

			Rectangle view = this.getBounds();

			Grid world = getWorld();
			Grid worldXY = getWorldXY();

			world.setNorth(-180.0);
			world.setSouth(180.0);
			world.setEast(-180.0);
			world.setWest(180.0);

			parser.maxWorld(world, segments);

			projection.toProjection(world, worldXY);

			worldXY.setNorth(180.0);
			worldXY.setSouth(-180.0);
			worldXY.setEast(180.0);
			worldXY.setWest(-180.0);

			paintGrid(g, worldXY, world, view);

			parser.plotSegments(g, worldXY, view, segments);

		}
	}

	/**
	 * ---------------------------------------------------------- * * *
	 * 
	 * @param *
	 * @return *
	 * @exception * * ----------------------------------------------------------
	 */

	public void print(String filename, Node node) {

		if (filename == null) {
			print(System.out, node);
			return;
		}

		try {
			PrintStream out = new PrintStream(new FileOutputStream(filename));

			print(out, node);

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * ---------------------------------------------------------- * * *
	 * 
	 * @param *
	 * @return *
	 * @exception * * ----------------------------------------------------------
	 */

	public void printAttributes(PrintStream out, Node node) {

		if (node == null)
			return;

		NamedNodeMap attr = node.getAttributes();
		if (attr == null)
			return;

		for (int i = 0; i < attr.getLength(); i++) {
			Node item = (Node) attr.item(i);
			if (item == null)
				continue;

			print(out, item);
		}
	}

	/**
	 * ---------------------------------------------------------- * * *
	 * 
	 * @param *
	 * @return *
	 * @exception * * ----------------------------------------------------------
	 */

	public void print(PrintStream out, Node node) {

		Node child = null;

		if (node == null)
			return;

		switch (node.getNodeType()) {
		case Node.ELEMENT_NODE:
			if (node.getFirstChild() == null && node.hasAttributes() == false) {
				out.print("<" + node.getNodeName() + "/>");
				return;
			}

			out.print("<" + node.getNodeName() + " ");

			printAttributes(out, node);

			if (node.getFirstChild() == null) {
				out.print("/>");
				return;
			}

			out.print(">");
			child = node.getFirstChild();
			while (child != null) {
				if (child.getNodeType() != Node.ATTRIBUTE_NODE) {
					print(out, child);
				}
				child = child.getNextSibling();
			}
			out.print("</" + node.getNodeName() + ">");
			return;
		case Node.TEXT_NODE:
			out.print(node.getNodeValue());
			break;
		case Node.CDATA_SECTION_NODE:
			out.print(node.getNodeValue());
			break;
		case Node.ATTRIBUTE_NODE:
			out.print(node.getNodeName() + "=\"" + node.getNodeValue() + "\" ");
			break;
		case Node.ENTITY_REFERENCE_NODE:
			break;
		case Node.ENTITY_NODE:
			break;
		case Node.PROCESSING_INSTRUCTION_NODE:
			out.print("<" + node.getNodeValue() + ">");
			break;
		case Node.COMMENT_NODE:
			out.print("<!-- " + node.getNodeValue() + " -->");
			break;
		case Node.DOCUMENT_NODE:
			printChildren(out, node);
			return;
		case Node.DOCUMENT_TYPE_NODE:
			break;
		case Node.DOCUMENT_FRAGMENT_NODE:
			break;
		case Node.NOTATION_NODE:
			break;
		default:
			break;
		}

		if (node.hasChildNodes() == true) {
			System.out.println("ERROR: not processing children.");
		}

	}

	private void printChildren(PrintStream out, Node node) {
		Node child = node.getFirstChild();
		while (child != null) {
			print(out, child);
			child = child.getNextSibling();
		}
	}

	// ---------------------------------------------------------------------------------
	// Listeners
	// ---------------------------------------------------------------------------------

	class ExitListener implements ActionListener {
		public void actionPerformed(ActionEvent e) {
			// TODO - check if any outstaning edits.
			System.exit(0);
		}
	}

	// ---------------------------------------------------------------------------------
	// MAIN
	// ---------------------------------------------------------------------------------
	public static void main(String args[]) {

		WorldParser parser = new WorldParser();

		boolean validate = false;
		String xmlfilename = null, savefilename = null;

		int width = 500, height = 500;

		for (int i = 0; i < args.length; i++) {
			if ("-xml".equalsIgnoreCase(args[i])) {
				xmlfilename = args[++i];
			} else if ("-width".equalsIgnoreCase(args[i])) {
				width = parser.toInt(args[++i]);
			} else if ("-height".equalsIgnoreCase(args[i])) {
				height = parser.toInt(args[++i]);
			} else if ("-projection".equalsIgnoreCase(args[i])) {
				parser.projection = MapProjection.getInstance(args[++i]);
			} else if ("-validate".equalsIgnoreCase(args[i])) {
				validate = true;
			} else if ("-save".equalsIgnoreCase(args[i])) {
				savefilename = args[++i];
			} else if ("-show".equalsIgnoreCase(args[i])) {
				parser.createWorldFrame(width, height);
				System.exit(0);
			}
		}

		parser.Convert(xmlfilename, validate);
		if (savefilename != null) {
			parser.print(savefilename, parser.getDocument());
		}
	}
}

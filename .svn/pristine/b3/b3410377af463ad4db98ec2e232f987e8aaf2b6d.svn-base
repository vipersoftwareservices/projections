/*
 * --------------------------------------------------------------
 *               VIPER SOFTWARE SERVICES
 * --------------------------------------------------------------
 *
 * @(#)filename.java	1.00 2003/06/15
 *
 * Copyright 1998-2003 by Viper Software Services
 * 36710 Nichols Ave, Fremont CA, 94536
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Viper Software Services. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Viper Software Services.
 *
 * @author Tom Nevin (TomNevin@pacbell.net)
 *
 * @version 1.0, 06/15/2003 
 *
 * @note 
 *        
 * ---------------------------------------------------------------
 */

import world.*;
import java.text.*;
import java.util.*;

public class MapTests {

	transient NumberFormat NF = NumberFormat.getIntegerInstance();

 	int ITERATIONS = 1;
	double ACCURRACY = 0.001;

	long startTime, stopTime;

	boolean passed = true;
  
class ItemTest {

	String utm;
	MapPoint value;
	MapPoint expected;

	public ItemTest(double ilon, double ilat, double olon, double olat) {
		this.value = new MapPoint(ilat, ilon);
		this.expected = new MapPoint(olat, olon);
	}

	public ItemTest(double olon, double olat, String utm) {
		this.utm = utm;
		this.expected = new MapPoint(olat, olon);
	}
}

class BearingTest {
	MapPoint value;
	MapPoint expected;
	double bearing;
	double distance;

	public BearingTest(
			double ilon, double ilat,
			double bearing, double distance,
			double olon, double olat) {

		this.value = new MapPoint(ilat, ilon);
		this.expected = new MapPoint(olat, olon);
		this.bearing = bearing;
		this.distance = distance;
	}
}

/** ----------------------------------------------------------
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public MapTests() {
}

/** ----------------------------------------------------------
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public int toInt(String str) {
	if (str == null || str.length() == 0) {
		return 0;
	}
	try {
		return Integer.parseInt(str.trim());
	} catch (NumberFormatException e) {
		e.printStackTrace();
	}
	return 0;
}

/** ----------------------------------------------------------
 **
 **
 **
 ** ----------------------------------------------------------
 **/
    
public double toDouble(String str) {
	if (str == null || str.length() == 0) {
		return 0.0;
	}

	try {
		return Double.parseDouble(str);
	} catch (Exception e) {
		e.printStackTrace();
        }
	return 0.0;
}

/** ----------------------------------------------------------
 **
 **
 **
 ** ----------------------------------------------------------
 **/
    
public String toString(double value, int maxDigits) {

	NF.setMaximumFractionDigits(maxDigits);

	return NF.format(value);
}

/**
 * Returns a string representation of this point and its location 
 * in the (<i>lat</i>,&nbsp;<i>lon</i>) coordinate space. This method is 
 * intended to be used only for debugging purposes, and the content 
 * and format of the returned string may vary between implementations. 
 * The returned string may be empty but may not be <code>null</code>.
 * 
 * @return  a string representation of this point
 */

public String toString(MapPoint pt) {

	return "[lat="+toString(pt.lat, 5)+",lon=" + toString(pt.lon, 5) + "]";
}

/** ----------------------------------------------------------
 **
 **
 **
 ** ----------------------------------------------------------
 **/
    
public double abs(double value) {
	return (value < 0.0) ? -value : value;
}

private void setStartTime() {
	startTime = System.currentTimeMillis();
}

private void setStopTime() {
	stopTime = System.currentTimeMillis();
}

public void setIterations(int iterations) {
	this.ITERATIONS = iterations;
}

public int getIterations() {
	return this.ITERATIONS;
}

public void setAccurracy(double accurracy) {
	this.ACCURRACY = accurracy;
}

public double getAccurracy() {
	return this.ACCURRACY;
}

public void printResults(String title) {  

	if (getIterations() <= 1) {
		return;
	}

	String results = (passed) ? "SUCCESS" : "FAILURE";

	System.out.print(results);
	System.out.print(" <- ");
	System.out.println(title);

	long dtime = stopTime - startTime;
		
	System.out.print(title);
	System.out.print(" : ");
	System.out.print(dtime/1000);
	System.out.print(" seconds, for ");
	System.out.print(getIterations());
	System.out.print(" ITERATIONS: ");
	System.out.print(dtime/getIterations());
	System.out.println(" millisecs per iteration.");
}

public void reset() {
	passed = true;
}

public void setResults(String title, MapProjection pr, MapPoint actual, MapPoint expect) {

	if (getIterations() != 1) {
		return;
	}
      
	if (equals(actual, expect) == true) {
		System.out.println("PASSED: "+title);
		return;
	} 

	passed = false;
	System.out.println("FAILED: "+title);

	System.out.println(pr.toString());
	System.out.print("\tActual=");
	System.out.println(toString(actual));
	System.out.print("\tExpect=");
	System.out.println(toString(expect));
}

public void setResults(String title, MapProjection pr, double actual, double expect) {

	if (getIterations() != 1) {
		return;
	}

	if (actual == expect) {
		System.out.println("PASSED: "+title);
		return;
	} 

	passed = false;
	System.out.println("FAILED: "+title);

	System.out.println(pr.toString());
	System.out.print("\tActual=");
	System.out.println(actual);
	System.out.print("\tExpect=");
	System.out.println(expect);
}

public void setResults(String title, MapProjection pr, String actual, String expect) {
    
	if (getIterations() != 1) {
		return;
	}

	if (actual == expect) {
		System.out.println("PASSED: "+title);
		return;
	}

	passed = false;
	System.out.println("FAILED: "+title);

	System.out.println(pr.toString());
	System.out.print("\tActual=");
	System.out.println(actual);
	System.out.print("\tExpect=");
	System.out.println(expect);
}

public boolean equals(double v1, double v2) {
	double delta = v2 - v1;
	if (delta < 0.0) {
		delta = -delta;
	}

	return (delta <= ACCURRACY);
}

public boolean equals(MapPoint pt1, MapPoint pt2) {

	return equals(pt1.lat, pt2.lat) && equals(pt1.lon, pt2.lon);

}
  
/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test03() {
     
 	Vector tests0 = new Vector();
 	tests0.add(new ItemTest(90.0, 0.0, 90.0, 0.0));
 	tests0.add(new ItemTest(80.0, 0.0, 80.0, 0.0));
 	tests0.add(new ItemTest(70.0, 0.0, 70.0, 0.0));
 	tests0.add(new ItemTest(60.0, 0.0, 60.0, 0.0));
 	tests0.add(new ItemTest(50.0, 0.0, 50.0, 0.0));
 	tests0.add(new ItemTest(40.0, 0.0, 40.0, 0.0));
 	tests0.add(new ItemTest(30.0, 0.0, 30.0, 0.0));
 	tests0.add(new ItemTest(20.0, 0.0, 20.0, 0.0));
 	tests0.add(new ItemTest(10.0, 0.0, 10.0, 0.0));
 	tests0.add(new ItemTest( 0.0, 0.0,  0.0, 0.0));
 	tests0.add(new ItemTest(90.0, 10.0, 90.0000, 0.0)); 
 	tests0.add(new ItemTest(80.0, 10.0, 80.1161, 2.45283)); 
 	tests0.add(new ItemTest(70.0, 10.0, 70.1764, 4.43526)); 
 	tests0.add(new ItemTest(60.0, 10.0, 60.1995, 6.03553)); 
 	tests0.add(new ItemTest(50.0, 10.0, 50.1962, 7.31380)); 
 	tests0.add(new ItemTest(40.0, 10.0, 40.1752, 8.31419)); 
 	tests0.add(new ItemTest(30.0, 10.0, 30.1410, 9.06533)); 
 	tests0.add(new ItemTest(20.0, 10.0, 20.0987, 9.58902)); 
 	tests0.add(new ItemTest(10.0, 10.0, 10.0502, 9.89784)); 
 	tests0.add(new ItemTest( 0.0, 10.0, 0.00000, 9.99983));
     
 	reset();
 	setStartTime();
 
 	MapPoint answer = new MapPoint();
 	Azimuthal azimuthal = new Azimuthal();
 	azimuthal.setOriginLon(0.0);
 	azimuthal.setEccentricity(azimuthal.EarthEccentricity);
 	azimuthal.setRadius(azimuthal.EquatorialRadius);

	for (int j = 0; j < getIterations(); j++) {

		for (int i = 0; i < tests0.size(); i++) {
			ItemTest item = (ItemTest)tests0.elementAt(i);

			azimuthal.toProjection(item.value, answer);

			setResults("Azimuthal.#0:"+i, azimuthal,answer, item.expected);
		}
	
	}

	setStopTime();	

	printResults("Test03");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test05() {

	MapPoint answer = new MapPoint();
	MapPoint value = new MapPoint();
	MapPoint expected = new MapPoint();

	// --------------------------------------------------------------
	// #7 Mercator (Sphere Forward) Page 266
	// --------------------------------------------------------------

	Mercator mercator = new Mercator();

	mercator.setOriginLon(-180.0);
	mercator.setEccentricity(1.0);
	mercator.setRadius(1.0);

	expected.lon = 1.8325957;
	expected.lat = 0.6528366;
	value.lon = -75.0;
	value.lat = 35.0;

	mercator.toProjection(value, answer);

	setResults("Test05.A", mercator, answer, expected);

	//--------------------------------------------------------------
	// #7 Mercator (Sphere Inverse) Page 267
	//--------------------------------------------------------------

	mercator.setOriginLon(-180.0);
	mercator.setEccentricity(1.0);
	mercator.setRadius(1.0);
	
	value.lon = 1.8325957;
	value.lat = 0.6528366;
	expected.lon = -75.0;
	expected.lat = 35.0;

	mercator.toLatLon(value, answer);
	
	setResults("Test05.B", mercator, answer, expected);

	//--------------------------------------------------------------
	// #7 Mercator (Forward Ellipse)  Page 267
	//--------------------------------------------------------------

	mercator.setOriginLon(-180.0);
	mercator.setEccentricity(mercator.EarthEccentricity);
	mercator.setRadius(mercator.EquatorialRadius);

	expected.lon = 11688673.71544;
	expected.lat =  4139145.635;
	value.lon = -75.0;
	value.lat = 35.0;

	mercator.toProjection(value, answer);

	setResults("Test05.C", mercator, answer, expected);

	//--------------------------------------------------------------
	//  #7 Mercator (Inverse Ellipse) Page 267-268
	//--------------------------------------------------------------

	mercator.setOriginLon(-180.0);
	mercator.setEccentricity(mercator.EarthEccentricity);
	mercator.setRadius(mercator.EquatorialRadius);

	value.lon = 11688673.71544;
	value.lat =  4139145.635;
	expected.lon = -75.0;
	expected.lat = 35.0;

	mercator.toLatLon(value, answer);

	setResults("Test05.D", mercator, answer, expected);

	//--------------------------------------------------------------
	// #8 Transverse Mercator (Forward Ellipse) Page 269-270
	//--------------------------------------------------------------

	TransverseMercator tm = new TransverseMercator();
	tm.setOriginLat(0.0);
	tm.setOriginLon(-75.0);
	tm.setEccentricity(mercator.EarthEccentricity);
	tm.setRadius(mercator.EquatorialRadius);

	expected.lat = 4484124.4;
	expected.lon = 127106.4676;
	value.lat = 40.5;
	value.lon = -73.5;

	tm.toProjection(value, answer);
	
	setResults("Test05.E", tm, answer, expected);

	//--------------------------------------------------------------
	// #8 Transverse Mercator (Inverse Ellipse) Page 270-271
	//--------------------------------------------------------------

	tm.setOriginLat(0.0);
	tm.setOriginLon(-75.0);
	tm.setEccentricity(mercator.EarthEccentricity);
	tm.setRadius(mercator.EquatorialRadius);
   
	expected.lat = 40.5;
	expected.lon = -73.5;
	value.lat = 4484124.4;
	value.lon = 127106.4676;
	
	tm.toLatLon(value, answer);

	setResults("Test05.F", tm, answer, expected);

	//--------------------------------------------------------------
	// #11 Miller (Forward Sphere) Page 287
	//--------------------------------------------------------------

	Miller miller = new Miller();
	miller.setOriginLon(0.0);
	miller.setRadius(1.0);

	expected.lat = 0.9536371;
	expected.lon = -1.3089969;
	value.lat = 50.0;
	value.lon = -75.0;
	
	miller.toProjection(value, answer);
	
	setResults("Test05.G", miller, answer, expected);

	//--------------------------------------------------------------
	// #11 Miller (Inverse Sphere) Page 287-288
	//--------------------------------------------------------------

	miller.setOriginLon(0.0);
	miller.setRadius(1.0);

	value.lat = 0.9536371;
	value.lon = -1.3089969;
	expected.lat = 50.0;
	expected.lon = -75.0;
    
	miller.toLatLon(value, answer);

	setResults("Test05.H", miller, answer, expected);

	//--------------------------------------------------------------
	// #13 Cassini (Forward Sphere) Page 288
	//--------------------------------------------------------------

	Cassini cassini = new Cassini();
	cassini.setOriginLat(-20.0);
	cassini.setOriginLon(-75.0);
	cassini.setEccentricity(1.0);
	cassini.setRadius(1.0);
 
	expected.lat = 0.7988243;
	expected.lon = -0.2367759;
	value.lat = 25.0;
	value.lon = -90.0;
	
	cassini.toProjection(value, answer);

	setResults("Test05.I", cassini, answer, expected);

	//--------------------------------------------------------------
	// #13 Cassini (Inverse Sphere) Page 288-289
	//--------------------------------------------------------------

	cassini.setOriginLat(-20.0);
	cassini.setOriginLon(-75.0);
	cassini.setEccentricity(1.0);
	cassini.setRadius(1.0);

	value.lat = 0.7988243;
	value.lon = -0.2367759;
	expected.lat = 25.0;
	expected.lon = -90.0;
    
	cassini.toLatLon(value, answer);

	setResults("Test05.J", cassini, answer, expected);

	//--------------------------------------------------------------
	// #14 Albers (Forward Sphere) Page 291
	//--------------------------------------------------------------

	Albers albers = new Albers();
	albers.setOriginLat(23.0);
	albers.setOriginLon(-96.0);
	albers.setParallel1(29.50);
	albers.setParallel2(45.30);
	albers.setEccentricity(1.0);
	albers.setRadius(1.0);

	expected.lat = 0.2416774;
	expected.lon = 0.2952720;
	value.lat = 35.0;
	value.lon = -75.0;
	
	albers.toProjection(value, answer);

	setResults("Test05.K", albers, answer, expected);

	//--------------------------------------------------------------
	// #14 Albers (Inverse Sphere) Page 291-292
	//--------------------------------------------------------------

	albers.setOriginLat(23.0);
	albers.setOriginLon(-96.0);
	albers.setParallel1(29.50);
	albers.setParallel2(45.30);
	albers.setEccentricity(1.0);
	albers.setRadius(1.0);

	value.lat = 0.2416774;
	value.lon = 0.2952720;
	expected.lat = 35.0;
	expected.lon = -75.0;
    
	albers.toLatLon(value, answer);

	setResults("Test05.L", albers, answer, expected);

	//--------------------------------------------------------------
	// #15 Lambert Conformal Conic (Forward Ellipse) Page 296-297
	//--------------------------------------------------------------

	LambertConformalConic lcc = new LambertConformalConic();
	lcc.setOriginLat(23.0);
	lcc.setOriginLon(-96.0);
	lcc.setParallel1(33.0);
	lcc.setParallel2(45.0);
	lcc.setEccentricity(lcc.EarthEccentricity);
	lcc.setRadius(lcc.EquatorialRadius);

	expected.lat = 1564649.4721;
	expected.lon = 1894410.90074;
	value.lat = 35.0;
	value.lon = -75.0;

	lcc.toProjection(value, answer);	

	setResults("Test05.M", lcc, answer, expected);

	//--------------------------------------------------------------
	// #15 Lambert Conformal Conic (Inverse Ellipse) Page 297-298
	//--------------------------------------------------------------

	lcc.setOriginLat(23.0);
	lcc.setOriginLon(-96.0);
	lcc.setParallel1(33.0);
	lcc.setParallel2(45.0);
	lcc.setEccentricity(lcc.EarthEccentricity);
	lcc.setRadius(lcc.EquatorialRadius);

	expected.lat = 35.0;
	expected.lon = -75.0;
	value.lat = 1564649.4721;
	value.lon = 1894410.90074;
  
	lcc.toLatLon(value, answer);	

	setResults("Test05.N", lcc, answer, expected);

	//--------------------------------------------------------------
	// #16 Equidistant Conic (Forward Sphere) Page 298-299
	//--------------------------------------------------------------

	EquidistantConic edc = new EquidistantConic();
	edc.setOriginLat(23.0);
	edc.setOriginLon(-96.0);
	edc.setParallel1(33.0);
	edc.setParallel2(45.0);
	edc.setEccentricity(1.0);
	edc.setRadius(1.0);

	expected.lat = 0.2424021;
	expected.lon = 0.2952057;
	value.lat = 35.0;
	value.lon = -75.0;

	edc.toProjection(value, answer);	
	
	setResults("Test05.EquidistantConic", edc, answer, expected);

	//--------------------------------------------------------------
	// #16 Equidistant Conic (Inverse Sphere) Page 299
	//--------------------------------------------------------------

	edc.setOriginLat(23.0);
	edc.setOriginLon(-96.0);
	edc.setParallel1(33.0);
	edc.setParallel2(45.0);
	edc.setEccentricity(1.0);
	edc.setRadius(1.0);

	value.lat = 0.2424021;
	value.lon = 0.2952057;
	expected.lat = 35.0;
	expected.lon = -75.0;

	edc.toLatLon(value, answer);	

	setResults("Test05.EquidistantConic", edc, answer, expected);

	//--------------------------------------------------------------
	// #18 Polyconic (Forward Sphere) Page 303
	//--------------------------------------------------------------

	Polyconic pc = new Polyconic();
	pc.setOriginLat(30.0);
	pc.setOriginLon(-96.0);
	pc.setEccentricity(1.0);
	pc.setRadius(1.0);

	expected.lat = 0.2074541;
	expected.lon = 0.2781798;
	value.lat = 40.0;
	value.lon = -75.0;

	pc.toProjection(value, answer);	

	setResults("Test05.Polyconic", pc, answer, expected);

	//--------------------------------------------------------------
	// #18 Polyconic (Inverse Sphere) Page 299
	//--------------------------------------------------------------

	pc.setOriginLat(30.0);
	pc.setOriginLon(-96.0);
	pc.setEccentricity(1.0);
	pc.setRadius(1.0);

	value.lat = 0.2074541;
	value.lon = 0.2781798;
	expected.lat = 40.0;
	expected.lon = -75.0;
  
	pc.toLatLon(value, answer);	

	setResults("Test05.Polyconic", pc, answer, expected);

	//--------------------------------------------------------------
	// #20 Orthographic (Forward Sphere) Page 311
	//--------------------------------------------------------------

	Orthographic ortho = new Orthographic();
	ortho.setOriginLon(-100.0);
	ortho.setParallel1(40.0);
	ortho.setEccentricity(1.0);
	ortho.setRadius(1.0);

	expected.lat = -0.1651911;
	expected.lon = -0.1503837;
	value.lat = 30.0;
	value.lon = -110.0;

	ortho.toProjection(value, answer);	

	setResults("Test05.Orthographic", ortho, answer, expected);

	//--------------------------------------------------------------
	// #20 Orthographic (Inverse Sphere) Page 312
	//--------------------------------------------------------------

	ortho.setOriginLon(-100.0);
	ortho.setParallel1(40.0);
	ortho.setEccentricity(1.0);
	ortho.setRadius(1.0);

	value.lat = -0.1651911;
	value.lon = -0.1503837;
	expected.lat = 30.0;
	expected.lon = -110.0;
  
	ortho.toLatLon(value, answer);	

	setResults("Test05.Orthographic", ortho, answer, expected);

	//--------------------------------------------------------------
	// #21 Stereographic (Forward Sphere) Page 312
	//--------------------------------------------------------------

	Stereographic stereo = new Stereographic();
	stereo.setOriginLon(-100.0);
	stereo.setParallel1(40.0);
	stereo.setEccentricity(1.0);
	stereo.setRadius(1.0);

	expected.lat = -0.1263802;
	expected.lon = 0.3807224;
	value.lat = 30.0;
	value.lon = -75.0;

	stereo.toProjection(value, answer);	

	setResults("Test05.Stereographic", stereo, answer, expected);

	//--------------------------------------------------------------
	// #21 Stereographic (Inverse Sphere) Page 313
	//--------------------------------------------------------------

	stereo.setOriginLon(-100.0);
	stereo.setParallel1(40.0);
	stereo.setEccentricity(1.0);
	stereo.setRadius(1.0);

	value.lat = -0.1263802;
	value.lon = 0.3807224;
	expected.lat = 30.0;
	expected.lon = -75.0;
  
	stereo.toLatLon(value, answer);	

	setResults("Test05.Stereographic", stereo, answer, expected);

	//--------------------------------------------------------------
	// #22 Gnomonic (Forward Sphere) Page 319-320
	//--------------------------------------------------------------

	Gnomonic gnomonic = new Gnomonic();
	gnomonic.setOriginLon(-100.0);
	gnomonic.setParallel1(40.0);
	gnomonic.setEccentricity(1.0);
	gnomonic.setRadius(1.0);

	expected.lat = -0.1694739;
	expected.lon = -0.1542826;
	value.lat = 30.0;
	value.lon = -110.0;

	gnomonic.toProjection(value, answer);	

	setResults("Test05.Gnomonic", gnomonic, answer, expected);

	//--------------------------------------------------------------
	// #22 Gnomonic (Inverse Sphere) Page 320
	//--------------------------------------------------------------

	gnomonic.setOriginLon(-100.0);
	gnomonic.setParallel1(40.0);
	gnomonic.setEccentricity(1.0);
	gnomonic.setRadius(1.0);

	value.lat = -0.1694739;
	value.lon = -0.1542826;
	expected.lat = 30.0;
	expected.lon = -110.0;
   
	gnomonic.toLatLon(value, answer);

	setResults("Test05.Gnomonic", gnomonic, answer, expected);

	//--------------------------------------------------------------
	// #23 General (Forward Sphere) Page 320-321
	//--------------------------------------------------------------

	General general = new General();
	general.setOriginLon(-77.0);
	general.setParallel1(39.0);
	general.setEccentricity(1.0);
	general.setRadius(6371.0);
	general.setPDistance(500.0);

	expected.lat = 222.48596;
	expected.lon = 247.19409;
	value.lat = 41.0;
	value.lon = -74.0;

	general.toProjection(value, answer);	

	setResults("Test05.General", general, answer, expected);

	//--------------------------------------------------------------
	// #23 General (Inverse Sphere) Page 321
	//--------------------------------------------------------------

	general.setOriginLon(-77.0);
	general.setParallel1(39.0);
	general.setEccentricity(1.0);
	general.setRadius(6371.0);
	general.setPDistance(500.0);

	value.lat = 222.48596;
	value.lon = 247.19409;
	expected.lat = 41.0;
	expected.lon = -74.0;

	general.toLatLon(value, answer);	

	setResults("Test05.General", general, answer, expected);

	//--------------------------------------------------------------
	// #24 Lambert Azimuthal Equal Area (Forward Sphere) Page 332
	//--------------------------------------------------------------

	AzimuthalEqualArea aea = new AzimuthalEqualArea();
	aea.setOriginLon(-100.0);
	aea.setParallel1(40.0);
	aea.setEccentricity(1.0);
	aea.setRadius(3.0);

	expected.lat = 4.0257775;
	expected.lon = -4.2339303;
	value.lat = -20.0;
	value.lon = 100.0;

	aea.toProjection(value, answer);

	setResults("Test05.Lambert", aea, answer, expected);

	//--------------------------------------------------------------
	// #24 Lambert Azimuthal Equal Area (Inverse Sphere) Page 332
	//--------------------------------------------------------------

	aea.setOriginLon(-100.0);
	aea.setParallel1(40.0);
	aea.setEccentricity(1.0);
	aea.setRadius(3.0);

	value.lat = 4.0257775;
	value.lon = -4.2339303;
	expected.lat = -20.0;
	expected.lon = 100.0;
    
	aea.toLatLon(value, answer);

	setResults("Test05.Lambert", aea, answer, expected);

	//--------------------------------------------------------------
	// #25 Azimuthal Equidistant (Forward Sphere) Page 337-338
	//--------------------------------------------------------------

	Azimuthal azimuthal = new Azimuthal();
	azimuthal.setOriginLon(-100.0);
	azimuthal.setParallel1(40.0);
	azimuthal.setEccentricity(0.0);
	azimuthal.setRadius(3.0);
  
	expected.set(5.5444634, -5.8311398);
	value.set(-20.0, 100.0);

	azimuthal.toProjection(value, answer);

	setResults("Test05.Azimuthal", azimuthal, answer, expected);

	//--------------------------------------------------------------
	// #25 Azimuthal Equidistant (Inverse Sphere) Page 338
	//--------------------------------------------------------------

	azimuthal.setOriginLon(-100.0);
	azimuthal.setParallel1(40.0);
	azimuthal.setEccentricity(0.0);
	azimuthal.setRadius(3.0);

	value.set(5.5444634, -5.8311398);
	expected.set(-20.0, 100.0);

	azimuthal.toLatLon(value, answer);

	setResults("Test05.Azimuthal", azimuthal, answer, expected);

	//--------------------------------------------------------------
	// #25 Azimuthal Equidistant (Forward Ellipse) Page 338-341
	//--------------------------------------------------------------

	azimuthal.setOriginLon(-100.0);
	azimuthal.setParallel1(90.0);
	azimuthal.setEccentricity(azimuthal.EarthEccentricity);
	azimuthal.setRadius(azimuthal.EquatorialRadius);

	expected.set(289071.2, 1078828.3);
	value.set(80.0, 5.0);

	azimuthal.toProjection(value, answer);

	setResults("Test05.Azimuthal", azimuthal, answer, expected);

	//--------------------------------------------------------------
	// #25 Azimuthal Equidistant (Inverse Ellipse) Page 341-344
	//--------------------------------------------------------------

	azimuthal.setOriginLon(-100.0);
	azimuthal.setParallel1(90.0);
	azimuthal.setEccentricity(azimuthal.EarthEccentricity);
	azimuthal.setRadius(azimuthal.EquatorialRadius);
  
	value.set(289071.2, 1078828.3);
	expected.set(80.0, 5.0);

	azimuthal.toLatLon(value, answer);

	setResults("Test05.Azimuthal", azimuthal, answer, expected);

	//--------------------------------------------------------------
	// #27 Space Oblique Mercator (Forward Ellipse) Page 354-358
	//--------------------------------------------------------------

	SpaceObliqueMercator som = new SpaceObliqueMercator();
	som.setPath(15);
	som.setEccentricity(som.EarthEccentricity);
	som.setRadius(7294690.0);
	som.setIncline(99.092);
	som.setP1(251.0);
	som.setP2(18.0);
	som.setC1(128.87);
	som.setC2(251.0);
	som.setEarthRadius(som.EquatorialRadius);
  
	expected.set(760636.33, 15607700.94);
	value.set(40.0, -73.0);

	som.toProjection(value, answer);

	setResults("Test05.SpaceObliqueMercator", som, answer, expected);

	//--------------------------------------------------------------
	// #27 Space Oblique Mercator (Inverse Ellipse) Page 358-359
	//--------------------------------------------------------------

	som.setPath(15);
	som.setEccentricity(som.EarthEccentricity);
	som.setRadius(7294690.0);
	som.setIncline(99.092);
	som.setP1(251.0);
	som.setP2(18.0);
	som.setC1(128.87);
	som.setC2(251.0);
	som.setEarthRadius(som.EquatorialRadius);

	value.set(760636.33, 15607700.94);
	expected.set(40.0, -73.0);
  
	som.toLatLon(value, answer);

	setResults("Test05.SpaceObliqueMercator", som, answer, expected);
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test06() {

	MapPoint answer = new MapPoint();
	MapPoint value = new MapPoint();
	MapPoint expected = new MapPoint();

	double SP1 = 33.3;
	double SP2 = 66.6;
  
	System.out.println("Processing in Progress.....");
 
	for (double lon = -180.0; lon <= 180.0; lon=lon+10.0) { 
	for (double lat = -80.0; lat <= 80.0; lat=lat+10.0) { 

		for (int ptype = 0; ptype < 24; ptype++) {

			MapProjection pr = MapProjection.getInstance(ptype);
  
			value.set(lat, lon);
			SP1 = abs(SP1);
			SP2 = abs(SP2);
			if (value.lat < 0.0) {
				SP1 = -SP1;
				SP2 = -SP2;
			}

			double R = pr.EquatorialRadius;
/** TBD 2004
			if (ptype == pr.SOM) {
				R = 2.0 * R;
			}
 **/

/** TBD 2004
			pr.setPath(15);
			pr.setIncline(99.092);
			pr.setP1(251.0);
			pr.setP2(18.0);
			pr.setC1(128.87);
			pr.setC2(251.0);
			pr.setEarthRadius(pr.EquatorialRadius);
 **/
			pr.setOriginLat(0.0);
			pr.setOriginLon(0.0);
			pr.setParallel1(SP1);
			pr.setParallel2(SP2);
			pr.setEccentricity(pr.EarthEccentricity);
			pr.setRadius(R);

			pr.toProjection(value, answer);
		}
	}
	}

	System.out.println("Done.");
}
    
//     procedure TEST_11 is
//       
//       RESULT     : BOOLEAN = TRUE;
//       ANSWER_T   : constant POINT = (Y => 6.5, X => 5.1);
//       ANSWER_A   : constant POINT = (Y => 6.414, X => 3.5857);
//       ANSWER_1   : constant DOUBLE = 135.0;
//       ANSWER_2   : constant DOUBLE = 80.0;
//       
//       ACHIEVED_T : POINT;
//       ACHIEVED_A : POINT;
//       ACHIEVED_1 : DOUBLE;
//       ACHIEVED_2 : DOUBLE;
//       
//       PNT_1      : constant POINT = (1.0, 1.0);
//       PNT_2      : constant POINT = (5.0, 5.0);
//       PNT_3      : constant POINT = (10.0, 5.0);
//       RADIUS     : constant DOUBLE = 2.0;
//       ROTATION   : NAVIGATION.ROTATION_TYPE;
//       
//     begin
//       
//       startTime = CALENDAR.CLOCK;
//       
//       for I in 1 .. getIterations() loop
//         
//         NAVIGATION.TURN_OUT_POINT (PNT_1    => PNT_1, 
//                                    PNT_2    => PNT_2, 
//                                    PNT_3    => PNT_3, 
//                                    RADIUS   => RADIUS, 
//                                    PNT_T    => ACHIEVED_T, 
//                                    PNT_A    => ACHIEVED_A, 
//                                    ANGLE_1  => ACHIEVED_1, 
//                                    ANGLE_2  => ACHIEVED_2, 
//                                    ROTATION => ROTATION);
//         
//         if ANSWER_T /= ACHIEVED_T then
//           RESULT = FALSE;
//           setResults ("POINT_T", ACHIEVED_T, ANSWER_T);
//         end if;
//         if ANSWER_A /= ACHIEVED_A then
//           RESULT = FALSE;
//           setResults ("POINT_A", ACHIEVED_A, ANSWER_A);
//         end if;
//         if ANSWER_1 /= ACHIEVED_1 then
//           RESULT = FALSE;
//           setResults ("ANGLE_1", ACHIEVED_1, ANSWER_1);
//         end if;
//         if ANSWER_2 /= ACHIEVED_2 then
//           RESULT = FALSE;
//           setResults ("ANGLE_2", ACHIEVED_2, ANSWER_2);
//         end if;
//         
//       end loop;
//       
//       endTime = CALENDAR.CLOCK;
//       println (RESULT, "TEST_11");
//       printResults ("TEST_11");
//       
//     exception
//       when others =>
//         TEXT_IO.PUT_LINE ("ERROR in TEST_11!");
//         
//     end TEST_11;
//     
//     
//     procedure TEST_11A is
//       
//       RESULT     : BOOLEAN = TRUE;
//       ANSWER_T   : constant POINT = (Y => 6.3, 
//                                                X => 6.972);
//       ANSWER_A   : constant POINT = (Y => 5.0, 
//                                                X => 6.414);
//       ANSWER_1   : constant DOUBLE = 270.0;
//       ANSWER_2   : constant DOUBLE = 23.228;
//       
//       ACHIEVED_T : POINT;
//       ACHIEVED_A : POINT;
//       ACHIEVED_1 : DOUBLE;
//       ACHIEVED_2 : DOUBLE;
//       
//       PNT_1      : constant POINT = (Y => 0.0, X => 5.0);
//       PNT_2      : constant POINT = (Y => 5.0, X => 5.0);
//       PNT_3      : constant POINT = (Y => 5.0, X => 10.0);
//       RADIUS     : constant DOUBLE = 1.4142136;
//       ROTATION   : NAVIGATION.ROTATION_TYPE;
//       
//     begin
//       
//       startTime = CALENDAR.CLOCK;
//       
//       for I in 1 .. getIterations() loop
//         
//         NAVIGATION.TURN_OUT_POINT (PNT_1    => PNT_1, 
//                                    PNT_2    => PNT_2, 
//                                    PNT_3    => PNT_3, 
//                                    RADIUS   => RADIUS, 
//                                    PNT_T    => ACHIEVED_T, 
//                                    PNT_A    => ACHIEVED_A, 
//                                    ANGLE_1  => ACHIEVED_1, 
//                                    ANGLE_2  => ACHIEVED_2, 
//                                    ROTATION => ROTATION);
//         
//         if ANSWER_T /= ACHIEVED_T then
//           RESULT = FALSE;
//           setResults ("POINT_T", ACHIEVED_T, ANSWER_T);
//         end if;
//         if ANSWER_A /= ACHIEVED_A then
//           RESULT = FALSE;
//           setResults ("POINT_A", ACHIEVED_A, ANSWER_A);
//         end if;
//         if ANSWER_1 /= ACHIEVED_1 then
//           RESULT = FALSE;
//           setResults ("ANGLE_1", ACHIEVED_1, ANSWER_1);
//         end if;
//         if ANSWER_2 /= ACHIEVED_2 then
//           RESULT = FALSE;
//           setResults ("ANGLE_2", ACHIEVED_2, ANSWER_2);
//         end if;
//         
//       end loop;
//       
//       endTime = CALENDAR.CLOCK;
//       println (RESULT, "TEST_11A");
//       printResults ("TEST_11A");
//       
//     exception
//       when others =>
//         TEXT_IO.PUT_LINE ("ERROR in TEST_11A!");
//         
//     end TEST_11A;

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test13() {

	MapPoint MAGNETIC_NORTH_POLE = new MapPoint(78.9, -103.8);

 	Vector pts = new Vector();
 	pts.add(new MapPoint(  0.0,    0.0));
 	pts.add(new MapPoint( 45.0,   45.0));
 	pts.add(new MapPoint(  0.0, -103.8));
 	pts.add(new MapPoint( 50.0,    0.0));
 	pts.add(new MapPoint(  0.0,  -60.0));
 	pts.add(new MapPoint(  0.0, -180.0));

	reset();
	setStartTime();

	MapProjection pr = new General();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < pts.size(); i++) {
			MapPoint pt = (MapPoint)pts.elementAt(i);

			double answer = pr.getAzimuth(pt, MAGNETIC_NORTH_POLE);

			setResults("Test13."+i, pr, (double)i, answer);
		}
	}

	setStopTime();	
	printResults("Test13");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test14() {
      
 	Vector pts1 = new Vector();
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));

 	Vector pts2 = new Vector();
 	pts2.add(new MapPoint( 90.0,    0.0));
 	pts2.add(new MapPoint(  0.0,   90.0));
 	pts2.add(new MapPoint( 90.0,   90.0));
 	pts2.add(new MapPoint(-90.0,    0.0));
 	pts2.add(new MapPoint(  0.0,  -90.0));
 	pts2.add(new MapPoint(-90.0,  -90.0));

	double expected[] = {0.0, 90.0, 0.0, 180.0, 270.0, 180};

	reset();
	setStartTime();

	MapProjection pr = new General();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < expected.length; i++) {

			MapPoint pt1 = (MapPoint)pts1.elementAt(i);
			MapPoint pt2 = (MapPoint)pts2.elementAt(i);

			double answer = pr.getAzimuth(pt1, pt2);
          
			setResults("Bearing => ", pr, answer, expected[i]);
		}
	}

	setStopTime();	
	printResults("Test14");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test14A() {

 	Vector pts1 = new Vector();
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));
 	pts1.add(new MapPoint(  0.0,    0.0));

 	Vector pts2 = new Vector();
 	pts2.add(new MapPoint( 90.0,    0.0));
 	pts2.add(new MapPoint(  0.0,   90.0));
 	pts2.add(new MapPoint( 90.0,   90.0));
 	pts2.add(new MapPoint(-90.0,    0.0));
 	pts2.add(new MapPoint(  0.0,  -90.0));
 	pts2.add(new MapPoint(-90.0,  -90.0));
 	pts2.add(new MapPoint( 90.0,  -90.0));
 	pts2.add(new MapPoint(-90.0,   90.0));

	double expected[] = {0.0, 90.0, 45.0, 180.0, 270.0, 225.0, 315.0, 135.0};

	reset();
	setStartTime();

	MapProjection pr = new General();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < expected.length; i++) {

			MapPoint pt1 = (MapPoint)pts1.elementAt(i);
			MapPoint pt2 = (MapPoint)pts2.elementAt(i);
			double answer = pr.getBearing(pt1, pt2);
          
			setResults("Bearing => ", pr, answer, expected[i]);
		}
	}

	setStopTime();	
	printResults("Test14A");
}
    
/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test12A() {

	MapPoint latlon1 = new MapPoint(20.0, 50.0);
	MapPoint latlon2 = new MapPoint(20.0, 50.0);
	MapPoint latlon3 = new MapPoint(21.0, 50.0);
	MapPoint latlon4 = new MapPoint(19.0, 50.0);
	MapPoint latlon5 = new MapPoint(21.0, 50.0);

	MapPoint origin1 = new MapPoint(19.0, 50.0);
	MapPoint origin2 = new MapPoint(21.0, 50.0);
	MapPoint origin3 = new MapPoint(19.0, 50.0);
	MapPoint origin4 = new MapPoint( 0.0,  0.0);
	MapPoint origin5 = new MapPoint( 0.0,  0.0);

	MapPoint meters1 = new MapPoint();
	MapPoint meters2 = new MapPoint();
	MapPoint meters3 = new MapPoint();
	MapPoint meters4 = new MapPoint();
	MapPoint meters5 = new MapPoint();
	MapPoint metersA = new MapPoint();
	MapPoint metersB = new MapPoint();

	TransverseMercator pr = new TransverseMercator();
	pr.setOriginLat(0.0);
	pr.setOriginLon(0.0);
	pr.setRadius(pr.EquatorialRadius);
	pr.setEccentricity(pr.EarthEccentricity);

	reset();
	setStartTime();

	for (int j = 0; j < getIterations(); j++) {

		pr.setOriginLat(origin1.lat);
		pr.setOriginLon(origin1.lon);
		pr.toProjection(latlon1, meters1);

		pr.setOriginLat(origin2.lat);
		pr.setOriginLon(origin2.lon);
		pr.toProjection(latlon2, meters2);

		pr.setOriginLat(origin3.lat);
		pr.setOriginLon(origin3.lon);
		pr.toProjection(latlon3, meters3);

		pr.setOriginLat(origin4.lat);
		pr.setOriginLon(origin4.lon);
		pr.toProjection(latlon4, meters4);

		pr.setOriginLat(origin5.lat);
		pr.setOriginLon(origin5.lon);
		pr.toProjection(latlon4, meters5);

		metersA.lat = meters2.lat + meters1.lat;
		metersA.lon = meters2.lon + meters1.lon;
        
		metersB.lat = meters5.lat - meters4.lat;
		metersB.lon = meters5.lon - meters4.lon;
        
		setResults ("meters3, meters1 + meters2 ", pr, meters3, metersA);
		setResults ("meters3, meters5 -meters4 ", pr, meters3, metersB);
		setResults ("meters1, meters2 ", pr, meters1, meters2);
		setResults ("meters4, meters5 ", pr, meters4, meters5);
	}

	setStopTime();	
	printResults("Test12A");
}
    
/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test15() {

 	Vector tests0 = new Vector();
 	tests0.add(new ItemTest(4916.2, 749.8, "32UMV14805837"));
	tests0.add(new ItemTest(4919.0, 924.4, "32UNV29746277")); 
	tests0.add(new ItemTest(4939.9, 816.6, "32UMA47560195")); 
	tests0.add(new ItemTest(4942.8, 913.1, "32UNA15790680")); 
	tests0.add(new ItemTest(4823.2, 843.6, "32UMU79705930")); 
	tests0.add(new ItemTest(4930.0, 632.8, "32ULV22308610")); 
	tests0.add(new ItemTest(4939.6, 633.5, "32ULA23900390")); 
	tests0.add(new ItemTest(5041.4, 732.5, "32UMB03101635")); 
	tests0.add(new ItemTest(4809.0, 1007.1, "32UNU83403370")); 
	tests0.add(new ItemTest(4824.7, 1035.9, "32UPU18406320")); 
	tests0.add(new ItemTest(4943.7, 1049.4, "32UPA31401000")); 
	tests0.add(new ItemTest(4745.2, 1019.8, "32UNT99509000")); 
	tests0.add(new ItemTest(4756.3, 1142.3, "32UQU02001320")); 
	tests0.add(new ItemTest(4805.0, 1212.0, "32UUP03902910")); 
	tests0.add(new ItemTest(4755.0, 1054.6, "32UPU42700890")); 
	tests0.add(new ItemTest(4845.7, 1210.2, "32UUQ04200440")); 
	tests0.add(new ItemTest(4901.8, 1157.0, "32UQV15703510")); 
	tests0.add(new ItemTest(4925.8, 1139.3, "32UPV82507880"));

	reset();
	setStartTime();

	UTM utm = new UTM();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {
			ItemTest item = (ItemTest)tests0.elementAt(i);
			String answer = utm.toUTM(item.value);
          
			setResults("UTM.#15."+i, utm, answer, item.utm);
		}
	}

	setStopTime();	
	printResults("Test15");
}
    
/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test16() {
      
 	Vector tests0 = new Vector();
 	tests0.add(new ItemTest(4916.2, 749.8, "32UMV14805837"));
	tests0.add(new ItemTest(4919.0, 924.4, "32UNV29746277")); 
	tests0.add(new ItemTest(4939.9, 816.6, "32UMA47560195")); 
	tests0.add(new ItemTest(4942.8, 913.1, "32UNA15790680")); 
	tests0.add(new ItemTest(4823.2, 843.6, "32UMU79705930")); 
	tests0.add(new ItemTest(4930.0, 632.8, "32ULV22308610")); 
	tests0.add(new ItemTest(4939.6, 633.5, "32ULA23900390")); 
	tests0.add(new ItemTest(5041.4, 732.5, "32UMB03101635")); 
	tests0.add(new ItemTest(4809.0, 1007.1, "32UNU83403370")); 
	tests0.add(new ItemTest(4824.7, 1035.9, "32UPU18406320")); 
	tests0.add(new ItemTest(4943.7, 1049.4, "32UPA31401000")); 
	tests0.add(new ItemTest(4745.2, 1019.8, "32UNT99509000")); 
	tests0.add(new ItemTest(4756.3, 1142.3, "32UQU02001320")); 
	tests0.add(new ItemTest(4805.0, 1212.0, "32UUP03902910")); 
	tests0.add(new ItemTest(4755.0, 1054.6, "32UPU42700890")); 
	tests0.add(new ItemTest(4845.7, 1210.2, "32UUQ04200440")); 
	tests0.add(new ItemTest(4901.8, 1157.0, "32UQV15703510")); 
	tests0.add(new ItemTest(4925.8, 1139.3, "32UPV82507880"));

	reset();
	setStartTime();

	String answer = null;

	UTM utm = new UTM();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {
			ItemTest item = (ItemTest)tests0.elementAt(i);
			answer = utm.toUTM(item.expected);
          
			setResults("UTM.#16."+i, utm, answer, item.utm);
		}
	}

	setStopTime();	
	printResults("Test16");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test17() {

 	Vector tests0 = new Vector();
 	tests0.add(new ItemTest(  0.0,    0.0,  1.5708,     0.0));
 	tests0.add(new ItemTest( 90.0,    0.0, -1.5708,     0.0));
 	tests0.add(new ItemTest(-90.0,    0.0, -1.5708,     0.0));
 	tests0.add(new ItemTest(  0.0,  180.0,     0.0,  3.1416));
 	tests0.add(new ItemTest(  0.0, -180.0,     0.0, -3.1416));
 	tests0.add(new ItemTest(  0.0, -110.0,     0.0, -1.9199));
 	tests0.add(new ItemTest( 10.0,   10.0,  0.1745,  0.1754));
 	tests0.add(new ItemTest( 10.0,   30.0,  0.1745,  0.5236));
 	tests0.add(new ItemTest( 10.0,   50.0,  0.1745,  0.8726));
 	tests0.add(new ItemTest( 10.0,   70.0,  0.1745,  1.2220));
 	tests0.add(new ItemTest( 10.0,  -20.0,  0.1745, -0.3490));
 	tests0.add(new ItemTest( 10.0,  -40.0,  0.1745, -0.6980));
 	tests0.add(new ItemTest( 30.0,  -20.0,  0.5235, -0.3490));
 	tests0.add(new ItemTest( 50.0,  -20.0,  0.8726, -0.3490));
 	tests0.add(new ItemTest( 70.0,  -20.0,  1.2217, -0.3490));

	reset();
	setStartTime();

	MapPoint answer = new MapPoint();

	EquidistantConic ec = new EquidistantConic();
	ec.setOriginLat(0.0);
	ec.setOriginLon(0.0);
	ec.setRadius(1.0);
	ec.setParallel1(0.0);
	ec.setParallel2(0.0);

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {

			ItemTest item = (ItemTest)tests0.elementAt(i);
			ec.toProjection(item.value, answer);
          
			setResults("Test17."+i, ec, answer, item.expected);
		}
	}

	setStopTime();	
	printResults("Test17");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test17A() {

 	Vector tests0 = new Vector();
 	tests0.add(new ItemTest(0.0, 0.0, 0.0, 1.1107));
	tests0.add(new ItemTest(90.0, 0.0, 1.5708, 1.1107));
	tests0.add(new ItemTest(-90.0, 0.0, -1.5708, 1.1107));
	tests0.add(new ItemTest(  0.0, 180.0, 0.0, -1.1107));
	tests0.add(new ItemTest(0.0, -180.0, 0.0, -1.1107));
	tests0.add(new ItemTest(  0.0, 110.0, 0.0, -1.9746));
	tests0.add(new ItemTest(10.0, 10.0, 0.1745, 1.234));
	tests0.add(new ItemTest(10.0, 30.0, 0.1745, 1.4809));
	tests0.add(new ItemTest(10.0, 50.0, 0.1745, 1.7278));
	tests0.add(new ItemTest(10.0, 70.0, 0.1745, 1.9746));
	tests0.add(new ItemTest(10.0, -20.0, 0.1745, 0.8639));
	tests0.add(new ItemTest(10.0, -40.0, 0.1745, 0.6171));
	tests0.add(new ItemTest(30.0, -20.0, 0.5235, 0.8639));
	tests0.add(new ItemTest(50.0, -20.0, 0.8726, 0.8639));
	tests0.add(new ItemTest(70.0, -20.0, 1.2217, 0.8639));

	reset();
	setStartTime();

	MapPoint answer = new MapPoint();

	EquidistantConic ec = new EquidistantConic();
	ec.setOriginLat(45.0);
	ec.setOriginLon(0.0);
	ec.setRadius(1.0);
	ec.setParallel1(45.0);
	ec.setParallel2(0.0);

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {

			ItemTest item = (ItemTest)tests0.elementAt(i);
			ec.toProjection(item.value, answer);
          
			setResults("Test17A."+i, ec, answer, item.expected);
		}
	}

	setStopTime();	
	printResults("Test17A");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test18() {

 	Vector tests0 = new Vector();
	tests0.add(new ItemTest( 0.0, 0.0, 0.0, 0.0)); 
	tests0.add(new ItemTest(90.0, 0.0, 1.5708, 0.0)); 
	tests0.add(new ItemTest(-90.0, 0.0, -1.5708, 0.0)); 
	tests0.add(new ItemTest( 0.0, 180.0,    0.0, 3.1416)); 
	tests0.add(new ItemTest( 0.0, -180.0, 0.0, -3.1416)); 
	tests0.add(new ItemTest( 0.0, 110.0,    0.0, 1.9199)); 
	tests0.add(new ItemTest(10.0, 10.0, 0.1745, 0.1745)); 
	tests0.add(new ItemTest(10.0, 30.0, 0.1745, 0.5236)); 
	tests0.add(new ItemTest(10.0, 50.0, 0.1745, 0.8726)); 
	tests0.add(new ItemTest(10.0, 70.0, 0.1745, 1.2217)); 
	tests0.add(new ItemTest(10.0, -20.0, 0.1745, -0.349)); 
	tests0.add(new ItemTest(10.0, -40.0, 0.1745, -0.698)); 
	tests0.add(new ItemTest(30.0, -20.0, 0.5235, -0.349)); 
	tests0.add(new ItemTest(50.0, -20.0, 0.8726, -0.349)); 
	tests0.add(new ItemTest(70.0, -20.0, 1.2217, -0.349));
      
	reset();
	setStartTime();

	MapPoint answer = new MapPoint();

	EquidistantConic ec = new EquidistantConic();
	ec.setOriginLat(0.0);
	ec.setOriginLon(0.0);
	ec.setRadius(1.0);

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {

			ItemTest item = (ItemTest)tests0.elementAt(i);
			ec.toLatLon(item.value, answer);
          
			setResults("Test18."+i, ec, answer, item.expected);
		}
	}

	setStopTime();	
	printResults("Test18");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test18A() {

	Vector tests0 = new Vector();
	tests0.add(new ItemTest(  0.0,    0.0,   0.0, 1.1107)); 
	tests0.add(new ItemTest( 90.0,    0.0,  1.5708, 1.1107)); 
	tests0.add(new ItemTest(-90.0,    0.0, -1.5708, 1.1107)); 
	tests0.add(new ItemTest(  0.0,  180.0, 0.0, -1.1107)); 
	tests0.add(new ItemTest(  0.0, -180.0, 0.0, -1.1107)); 
	tests0.add(new ItemTest(  0.0,  110.0, 0.0, -1.9746)); 
	tests0.add(new ItemTest( 10.0,   10.0, 0.1745, 1.234)); 
	tests0.add(new ItemTest( 10.0,   30.0, 0.1745, 1.4809)); 
	tests0.add(new ItemTest( 10.0,   50.0, 0.1745, 1.7278)); 
	tests0.add(new ItemTest( 10.0,   70.0, 0.1745, 1.9746)); 
	tests0.add(new ItemTest( 10.0,  -20.0, 0.1745, 0.8639)); 
	tests0.add(new ItemTest( 10.0,  -40.0, 0.1745, 0.6171)); 
	tests0.add(new ItemTest( 30.0,  -20.0, 0.5235, 0.8639)); 
	tests0.add(new ItemTest( 50.0,  -20.0, 0.8726, 0.8639)); 
	tests0.add(new ItemTest( 70.0,  -20.0, 1.2217, 0.8639));

	reset();
	setStartTime();

	MapPoint answer = new MapPoint();

	EquidistantConic ec = new EquidistantConic();
	ec.setOriginLat(0.0);
	ec.setOriginLon(-90.0);
	ec.setRadius(1.0);
	ec.setParallel1(45.0);

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {

			ItemTest item = (ItemTest)tests0.elementAt(i);
			ec.toLatLon(item.value, answer);
          
			setResults("Test18."+i, ec, answer, item.expected);
		}
	}

	setStopTime();	
	printResults("Test18A");
}

/** ----------------------------------------------------------
 **
 **
 ** @param
 ** @return
 ** @exception
 **
 ** ----------------------------------------------------------
 **/

public void Test19() {

 	Vector tests0 = new Vector();
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 0.0, 1.0, 0.0));
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 45.0, 0.7071067, 0.7071067));
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 90.0, 0.0, 1.0));
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 135.0, -07071067, 0.7071067));
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 180.0, -1.0, 0.0));
	tests0.add(new BearingTest(0.0, 0.0, 1.0, 275.0, 0.0, -1.0));

	reset();
	setStartTime();

	MapPoint answer = new MapPoint();

	MapProjection pr = new General();

	for (int j = 0; j < getIterations(); j++) {
		for (int i = 0; i < tests0.size(); i++) {

			BearingTest item = (BearingTest)tests0.elementAt(i);
			answer = pr.toLatLon2(item.value, item.distance, item.bearing, pr.EquatorialRadius);
          
			setResults("Test1."+i, pr, answer, item.expected);
		}
	}

	setStopTime();	
	printResults("Test19");
}

//     
//     procedure TEST_20 is
//       
//       RESULT : BOOLEAN = TRUE;
//       ANSWER : POINT;
//       
//       type value_RECORD is 
//         record
//           XY1 : POINT;
//           XY2 : POINT;
//         end record;
//       
//       type value_LIST is array (INT range <>) of value_RECORD;
//       
//       valueS   : value_LIST (1 .. 5) = (1 => ((00.0, 0.0), 
//                                              (1.0, 0.0)), 
//                                        2 => ((10.0, 0.0), 
//                                              (11.0, 0.0)), 
//                                        3 => ((0.0, 0.0), 
//                                              ( 0.0, 90.0)), 
//                                        4 => ((0.0, 0.0), 
//                                              (90.0, 0.0)), 
//                                        5 => ((0.0, 0.0), 
//                                              (90.0, 90.0)));
//       
//       expectedED : constant POINTS (1 .. 5) = (1 => ( 0.0, 60.0), 
//                                               2 => ( 0.0, 60.0), 
//                                               3 => (90.0, 60.0 * 90.0), 
//                                               4 => (0.0, 60.0 * 90.0), 
//                                               5 => (0.0, 60.0 * 90.0));
//       
//     begin
//       
//       startTime = CALENDAR.CLOCK;
//       
//       for I in 1 .. getIterations() loop
//         for INDEX in valueS'RANGE loop
//           
//           ANSWER.Y = NAVIGATION.AZIMUTH (valueS (INDEX).XY1, valueS (INDEX).XY2);
//           ANSWER.X = NAVIGATION.DISTANCE(valueS (INDEX).XY1, valueS (INDEX).XY2, NAVIGATION.EQUATORIAL_RADIUS);
//   
//           if ANSWER /= expectedED (INDEX) then
//              setResults ("BEARING/RANGE => ", ANSWER, expectedED (INDEX));
//           end if;
//           
//         end loop;
//       end loop;
//       
//       endTime = CALENDAR.CLOCK;
//       println (RESULT, "TEST_20");
//       printResults ("TEST_20");
//       
//     exception
//       when others =>
//         TEXT_IO.PUT_LINE ("ERROR in TEST_20!");
//         
//     end TEST_20;
//     
//     procedure DISPLAY (X0, Y0, D : DOUBLE;
//                        N         : INTEGER) is
//       
//       PROJ : POINT;
//       XY   : POINT;
//       
//     begin
//       
//       REAL_IO.PUT (INFO.Y0, 
//                    AFT => 4, 
//                    EXP => 0);
//       TEXT_IO.PUT_LINE (" <--ORIGIN LATITUDE.");
//       
//       REAL_IO.PUT (INFO.X0, 
//                    AFT => 4, 
//                    EXP => 0);
//       TEXT_IO.PUT_LINE (" <--ORIGIN LONGITUDE.");
//       
//       REAL_IO.PUT (INFO.SP1, 
//                    AFT => 4, 
//                    EXP => 0);
//       TEXT_IO.PUT_LINE (" <--STANDARD PARALLEL #1");
//       
//       REAL_IO.PUT (INFO.SP2, 
//                    AFT => 4, 
//                    EXP => 0);
//       TEXT_IO.PUT_LINE (" <--STANDARD PARALLEL #2");
//       
//       TEXT_IO.PUT_LINE ("PROJECTION           XY   ");
//       
//       XY.Y = DOUBLE (Y0);
//       XY.X = DOUBLE (X0);
//       
//       for X in 1 .. N loop
//         for Y in 1 .. N loop
//           NAVIGATION.PROJECTION (XY, INFO, PROJ);
//           
//           TEXT_IO.PUT (ASCII.HT & " ");
//           REAL_IO.PUT (PROJ.X, 
//                        AFT => 1, 
//                        EXP => 0);
//           TEXT_IO.PUT (ASCII.HT & " ");
//           REAL_IO.PUT (PROJ.Y, 
//                        AFT => 1, 
//                        EXP => 0);
//           
//           TEXT_IO.PUT (ASCII.HT & " : ");
//           REAL_IO.PUT (XY.X, 
//                        AFT => 1, 
//                        EXP => 0);
//           TEXT_IO.PUT (ASCII.HT & " ");
//           REAL_IO.PUT (XY.Y, 
//                        AFT => 1, 
//                        EXP => 0);
//           TEXT_IO.NEW_LINE;
//           
//           XY.Y = XY.Y + DOUBLE (D);
//         end loop;
//         
//         XY.X = XY.X + DOUBLE (D);
//         XY.Y = DOUBLE (Y0);
//         
//       end loop;
//       
//     exception
//       when others =>
//         TEXT_IO.PUT_LINE ("ERROR in DISPLAY");
//         
//     end DISPLAY;
//     
//     function ENTERED_FLOAT (DESCRIPTION : STRING) return DOUBLE is
//       
//       LINE   : STRING (1 .. 132) = (others => ASCII.NUL);
//       LAST   : NATURAL;
//       ANSWER : DOUBLE;
//       
//     begin
//       
//       TEXT_IO.NEW_LINE;
//       TEXT_IO.PUT ("Enter " & DESCRIPTION & " : ");
//       TEXT_IO.GET_LINE (LINE, LAST);
//       REAL_IO.GET (LINE (1 .. LAST), ANSWER, LAST);
//       
//       return ANSWER;
//       
//     end ENTERED_FLOAT;
//     
//     
//     function ENTERED_INTEGER (DESCRIPTION : STRING) return INTEGER is
//       
//       LINE   : STRING (1 .. 132) = (others => ASCII.NUL);
//       LAST   : NATURAL;
//       ANSWER : INTEGER;
//       
//     begin
//       
//       TEXT_IO.NEW_LINE;
//       TEXT_IO.PUT ("Enter " & DESCRIPTION & " : ");
//       TEXT_IO.GET_LINE (LINE, LAST);
//       ANSWER = INTEGER'VALUE (LINE (1 .. LAST));
//       
//       return ANSWER;
//       
//     end ENTERED_INTEGER;
//     
//     
//     procedure BASE_METERS is
//       
//       X0, Y0, D : DOUBLE;
//       N         : INTEGER;
//       
//     begin
//       
//       TEXT_IO.PUT_LINE ("Calculating all points within grid.");
//       
//       TEXT_IO.PUT ("Enter Projection Name (TM, LCC) : ");
//       TEXT_IO.GET_LINE (LINE, LAST);
//       INFO.KIND = PROJECTION_TYPE'VALUE (LINE (1 .. LAST));
//       
//       X0 = ENTERED_FLOAT ("Base Lon  (N.N)");
//       Y0 = ENTERED_FLOAT ("Base Lat  (N.N)");
//       D = ENTERED_FLOAT ("Step Size (N.N)");
//       N = ENTERED_INTEGER ("N Steps (N)");
//       
//       INFO.Y0 = ENTERED_FLOAT ("Origin Lat (N.N)");
//       INFO.X0 = ENTERED_FLOAT ("Origin Lon (N.N)");
//       INFO.SP1 = ENTERED_FLOAT ("Standard Parallel #1 (N.N)");
//       INFO.SP2 = ENTERED_FLOAT ("Standard Parallel #2 (N.N)");
//       
//       DISPLAY (X0, Y0, D, N);
//       
//     end BASE_METERS;

public static void main(String args[]) {  
 
	MapTests tests = new MapTests();
	tests.setIterations(1);
	tests.setAccurracy(0.001);
 
	for (int i = 0; i < args.length; i++) {
		if ("-accurracy".equalsIgnoreCase(args[i])) {
			tests.setAccurracy(tests.toDouble(args[++i]));

		} else if ("-n".equalsIgnoreCase(args[i])) {
			tests.setIterations(tests.toInt(args[++i]));

		} else if ("-mercator".equalsIgnoreCase(args[i])) {
			tests.Test01();

		} else if ("-quick".equalsIgnoreCase(args[i])) {
			tests.Test05();

		} else if ("-all".equalsIgnoreCase(args[i])) {

			tests.Test01();	// MERCATOR 
// 			tests.Test03();	// XY_TO_AZIMUTHAL_EQUIDISTANT
// 			tests.Test05();	// General USGS Examples
// 			tests.Test13();	// AZIMUTH (North Pole)
// 			tests.Test14();	// AZIMUTH (Poles and Equator)
// 			tests.Test14A();	// BEARING 
// 			tests.Test11();	// TURN_OUT_POINT
// 			tests.Test11A();	// TURN_OUT_POINT
// 			tests.Test12A();	// XY_TO_TM (Varying origins)
// 			tests.Test15();	// UTM_TO_XY
// 			tests.Test16();	// XY_TO_UTM
// 			tests.Test17();	// XY_TO_EQUIDISTANT_CYLINDRICAL
// 
// 	// (PARALLEL_LAT = 0.0, ORIGIN_LON = 0.0)
// 			tests.Test17A();	// XY_TO_EQUIDISTANT_CYLINDRICAL
// 
// 	// (PARALLEL_LAT = 45.0, ORIGIN_LON = -90.0)
// 			tests.Test18();	// EQUIDISTANT_CYLINDIRICAL_TO_XY
// 
// 	// (PARALLEL_LAT = 0.0, ORIGIN_LON = 0.0)
// 			tests.Test18A();	// EQUIDISTANT_CYLINDRICAL_TO_XY
// 
// 	// (PARALLEL_LAT = 45.0, ORIGIN_LON = -90.0)
// 			tests.Test19();	// XY2
// 	BASE_METERS();
// 			tests.Test05();	// USGS Examples
// 			tests.Test06();
// 			tests.Test01();	// MERCATOR 
// 			tests.Test20();	// Bearing/Range Tests.
// 			tests.Test17();
// 			tests.Test17A();
// 			tests.Test18();
// 			tests.Test18A();

		}
	}

	System.out.println("Done.");
}
}
